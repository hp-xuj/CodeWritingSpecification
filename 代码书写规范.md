# 代码书写规范(Python)

架构固然重要，代码整洁也是

宏大建筑中最细小的部分，比如关不紧的门，有点没铺平的地板，甚至是凌乱的桌面，都将会将整个大局的魅力毁灭殆尽

架构 -- 毛坯房

代码 -- 装修风格

## 1. 有意义的命名

- 名副其实(命名规则)
- 避免误导(切勿使用关键字**/**名称避免过度相似**/**切勿随意命名：a/b/c)
- 做有意义的区分(少出现冗余的废话/moneyAmount和money没区别)
- 使用读的出来的名称(BCR3CNT/PSZQ)
- 使用可搜索的名称
- 避免使用编码
- 命名建议（表格）

## 2. 包和导入

- 使用模块的全路径来导入每个模块

  ``推荐：from sound.effects import echo;``
  ``避免使用：from . import x 这种形式**``

- 导入模块方式

  ``1. 使用 import x 来导入包和模块``

  ``2. 使用 from x import y，其中x是包前缀，y是不带前缀的模块名 ``

  ``3. 使用 from x import y as z，如果同时需要导入的两个模块的名字都叫y或者y的名字太长了``

  ``4. 层级较深的模块推荐使用：from sound.effects import echo``

## 3. 异常处理

- 异常处理的优缺点

    **优点**：正常操作代码的控制流不会和错误处理代码混在一起，当某种错误发生时，它也允许控制流跳过多个框架，例如一步跳出N个嵌套的函数，而不必继续执行错误的代码

    **缺点**：容易忽略真正的错误，Bug

- 使用异常必须遵循的特定条件：

    1. 触发异常的方式：``raise MyExpection("Error Message")`` 或 ``raise MyExpection``

    2. 模块和包应该有自己特定的域和异常基类（建议）

    3. 永远不要使用``except:``语句，**除非你记录了关于错误的详细信息**，Python的``except:``会将所有的错误全部捕获，使用``except:``很容易隐藏真正的Bug

    4. 尽量减少``try/except``块中的代码量，其中代码体积越大，期望之外的错误就越容易触发，将会隐藏真正的错误。

    5. 捕获异常时，使用``as``

       ```Python
       try:
           raise Error
       except Error as error:
           logging.error("Error is %s" % e)
       ```

## 4. 全局变量   

- 避免使用全局变量，使用类变量来代替，除了以下情况：
  - 脚本默认选项
  - 模块级变量，例如：PI = 3.14159，常量应该全大写，用下划线连接
  - 有时候用全局变量来缓存或者作为函数返回值很有用
  - 全局变量应该仅再模块内使用，并通过模块的公共函数来访问

## 5. 列表推导

- 适用于简单情况，一次for循环并且没有复杂条件判断和数据处理的情况下可以使用
- 禁止多重for语句或过滤器表达式，复杂情况下还是使用循环

## 6. 默认迭代器和操作符

- 字典列表等容器类型的数据类型，推荐使用默认的 ``in`` 和 ``not in`` 操作符

- 判断``Bool``类型和``int``， `float`等数字类型时推荐使用 ``is`` 操作符而不是使用 ``==``

  ```Python
  a = 1
  b = 1
  print(a is b) # True
  
  
  a = True
  b = True
  
  print(a is b)  # True
  ```

## 7. 生成器

- 待补充 ……… 

## 8. Lambda函数/条件表达式

- 适用于单行函数，如果函数代码超过60 - 80个字符，请使用常规（嵌套）函数/完整的``if``语句

## 9. 默认参数值

- 默认参数只再模块加载的时候求值一次，所以参数不要使列表和和字典之类的可变类型，这可能会导致问题。

  ```Python
  # Yes:
  def foo(a, b=None):
      if b is None:
          b = []
  # No:  
  def foo(a, b=[]):
  def foo(a, b=time.time()):  
  def foo(a, b=FLAGS.my_thing): 
  ```

## 10. True/False的求值

- 尽可能使用隐式false

  - Python在Boolean上下文中会将某些值得求值看作为False，也就是所有的“空”值都会被认为Flase，因此0，None，[]，{}，"" 都会被认为是False

  - 永远不要用 ``==`` 和 ``!=``来比较单件，比如None，使用`is` 或 `is not`

  -  如果需要区分``None``和``False``，请使用：

    ```Python
    if not a and a is not None:
        pass
    ```

  - 对于序列（字符串，元组，列表），需要注意的是空序列是False，因此`if not result:` 和 ``if result:``比``if len(result)`` 和 ``if not len(result)``要更好

  - 处理整数时，小心使用隐式False，不要将None当作0来处理

  - **请注意！" " 和  "0" 都是 True！！！**

## 11. 装饰器，和词法作用域(闭包)

- 待补充………

## 12. 线程

- 不要依赖Python的内建类型如字典。在不同的线程间通讯时优先使用Queue模块的Queue类型作为通讯方式。
- 待补充……

## 13.  Python的语言特性

- 避免使用花哨的Python新特性。稳定和可读性是排在第一位的！

